
# Chapter 16. Version Control and Branch Management.  
  
  
  
## VCS - Version Control System  
- 가장 널리 쓰이고 있는 소프트웨어 엔지니어링 도구  
### VCS가 모든 소프트웨어 개발과 소프트웨어 엔지니어링에서 필수가 된 이유  
1. VCS를 도입하지 않을 경우 최신 버전 추적의 어려움  
	- 같은 프로젝트를 개발하는 여러 개발자가 서로 다른 시간에 개발을 진행할 경우 최신 버전의 프로젝트 추적이 어느정도 가능하다. 하지만, 동시에 여러 개발자가 같은 프로젝트를 개발할경우 '최신 버전 추적'이 어려운 상황에 놓이게 된다.  
	- 합의된 단일 진실 공급원(SSOT, Single Source of Truth)이 없는 환경이기 때문이다.  
	- 공유 스토리지를 도입하여 개발하게 될 경우 SSOT가 존재하여 조금더 만족스럽게 작업이 가능하지만 다른사람이 개발한 개발본을 덮어 씌울 수 있어서 위험하다.  
2. '즉각 이루어지는 소스 코드 생산'과 '제품을 장기간 지속 관리'하는 행위를 다른 차원으로 구분하여 줌.  
	- VCS는 표준 파일시스템을 확장한 개념으로 {파일 이름, 작성 시각} 조합을 파일 내용과 연결해주며, 동시에 마지막 동기화 지점과 리뷰 기록을 추적하는데 필요한 메타데이터를 관리 해줌. -> 코딩에서 정말 중요한 요소인 시간을 함께 관리 해줌.  
  
### 중앙집중형 VCS vs 분산형 VCS  
![]([https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190820174942/CVCS-vs-DVCS.png](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190820174942/CVCS-vs-DVCS.png))  
1. 중앙집중형 VCS (CVCS - Centralized VCS)  
	- 단 하나의 중앙 리포지터리를 이용하는 모델  
	- 각 파일을 체크하웃 하여 로컬 컴퓨터에서 이용 가능하지만 파일 추가, 동기화 등 버전 관리 상태와 관련한 작업을 할 경우 반드시 중앙 서버에 전달하여야함.  
	- 하나의 리포지토리에서 관리하므로, 새로운 커밋이 올라올 때 커밋에 포함된 모든 파일이 가장 최신 커밋을 기준으로 작성되었는지를 확인 후 커밋하는 과정을 거침.  
2. 분산형 VCS (DVCS - Distributed VCS)  
	- Git, Mercurial을 선두로 한 분산형 버전 관리 시스템  
	- '어디에 커밋하는가?'에 중점을 둔 시스템  
	- 분산형 VCS의 흐름  
		1. 기존 리포지터리를 로컬에 복제  
		2. 파일 변경 및 변경사항 커밋  
		3. (2)의 내용 반복  
		4. 로컬에 적용된 커밋 중 일부 혹은 전체를 다른 리포지토리로 커밋  
  
### 브랜치 관리  
1. 개발 브랜치(Develop Branch)  
	- '구현은 다 했지만 아직 커밋하진 않았어요'와 '이제부터 이 코드를 기준으로 개발하세요'의 중간 단계
	- 큰 변화를 주는 브랜치를 커밋하는 것 보다는 작게 자주 변경하는 것이 좋음
		- 똑같은 에러에 대한 커밋이 동시에 병합될 확률이 있음
		- 충돌이 발생할 가능성이 큼
			- 변화가 큰 브랜치를 여러명이 동시에 커밋 했을때 충돌에 대한 책임을 지기가 어려움
		- **소프트웨어 조직에서 흔히 겪는 생산성 저하 사례**
	- 그럼에도 불구하고 개발 브랜치에 중독이 되는 이유
		- 오래된 개발 브랜치를 병합하니 안정성이 떨어진다 -> 병합은 위험하다. -> 병합을 최대한 늦춘다.
		- 위와 같은 이유로 병합이 되지 않은 개발 브랜치에서 새로운 브랜치까지 만드는 팀이 등장할 수 있음.
2. 릴리즈 브랜치(Release Branch)
	- 제품의 릴리즈 간격 혹은 릴리즈 수명이 몇 시간 이상일 경우 릴리즈 브랜치를 따로 생성하는게 이득
	- 릴리즈한 제품과 정확하게 똑같은 코드
	- 다음 릴리즈 전에 심각한 결함이 발견될경우 해당 수정 코드를 최소한으로 선별하여 릴리즈 브랜치에 병합
	- 개발 브랜치와 다르게 대체로 무해함.
		- 개발 브랜치와의 가장 큰 차이점 -> 생을 마감하는 모습
			- 개발 브랜치 : 해당 브랜치에서 가지를 다시 뻗어 나갈 수 있음
			- 릴리즈 브랜치 : 홀로 존재하다가 생을 마감함
	- 구글의 DevOps Research and Assessment 조직의 연구에 따르면 최고 수준의 기술 조직에서는 릴리즈 브랜치 조차 존재 하지 않음
		- CD가 잘 자리 잡은 조직에서는 대체로 릴리즈 브랜치를 건너 뜀
	- 결론 : 브랜치는 생산성을 좀먹는다.


## 버전 관리 @ 구글
 - 소스코드의 대부분은 하나의 리포지터리(모노리포)에서 관리되며 약 5만명의 엔지니어에게 공유됨.
 - 자체 개발한 중앙집중형 VCS (Piper)를 이용하며 80TB가 넘는 콘텐츠, 메타데이터를 가지고 있음
	- Piper : Compute as a Service 기술로, 프로덕션 호나경에서 분산 마이크로 서비스 형태로 구동되게끔 만들어 세계 곳곳에 흩어져 있는 구글 엔지니어들에게 표준화된 스토리지와 소통 수단을 제공
	- 동시 편집을 지원하여 수천명의 엔지니어가 매일매일 쏟아내는 커밋을 받아줍니다.(하루 약 6~7만건의 커밋)
- 초기 구상 단계부터 확장성에 집중하여 투자한 덕분에 많은 구글 개발자들의 커밋을 견딜 수 있음
- 자체 개발 VCS의 장점
	- 본인들이 선택한 버전 관리 정책에 맞춰 시스템을 수정할 수 있음
		- ex.
			- 소유권 세분화
			- 리포지터리별 커밋 권한
			- 커밋 훅 추가 등
- **원 버전**
	- 어느 리포지토리의 어떤 브랜치가 메인 브랜치인지를 명확히 하도록 하는 '단일 진실 공급원'을 확장한 개념
	- '모든 의존성은 우리 리포지터리에 담겨 있고 각 의존성은 단 하나의 안정된 버전에만 존재해야 한다.'
		- 따라서 서드파티 패키지들도 Piper에는 단 하나의 버전만 저장해야함.
		- 내부 패키지는 다시 패키징 하거나 이름을 바꾸지 않고 포크가 불가능함.
- **원 버전 규칙**
	- 개발자가 **'이 구성 요소에는 어떤 버전을 사용해야 하죠?'** 라고 묻는 상황이 등장하지 않아야 함.
	- 즉, 의존성을 새로 추가할 때 **'선택'**할 수 있는 버전을 제한함.
	- 선택을 제한하는 건 자유를 침해하는 장애물처럼 보일 수 있으나, 조직 차원에서 바라볼 때, 효율적으로 확장하기 위해 반드시 필요한 규칙
- **장수 브랜치 금지**
	- 개발 브랜치를 되도록 만들지 말고, 만들더라도 매우 짧게 쓰고 없애야함.
- **릴리즈 브랜치**는 최소한의 수정만 허용
	- 배포된 정확한 버전을 파악하기 용이함
	- 지속적 배포(CD)가 잘 되어있는 팀은 릴리즈 브랜치를 생략하기도 함.
## 모노리포
- 모노리포의 이점
	1. 원 버전을 고수하기가 쉬움
	2. 공식 버전 혹은 중심 역할을 하는 리포지터리를 찾는 과정이 불 필요함.
	3. 도구를 새로 도입하거나 코드를 최적화한 혜택이 조직 전체에 훨씬 빠르게 전파됨
	4. 다른 엔지니어들이 무슨 일을 어떻게 하고 있는지 쉽게 알아볼 수 있음
		- 이를 이용하여 자신의 코드와 시스템 설계 방향을 결정 할 수 있음
- 단 모노리포가 무조건적인 정답은 아님.
- 모노리포 VS 멀티리포
	- 소스코드를 저장하는 방법에대한 고민을 해야 함.
	- 본인들이 속한 조직의 특성과 워크플로의 특정 세부 이슈가 더 중요할 경우를 고려해야함.
